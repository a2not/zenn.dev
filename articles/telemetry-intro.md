---
title: "Transparent Telemetry for Open-Source Projectsを読む"
emoji: "🌌"
type: "tech"
topics: ["go", "oss", "proposal"]
published: false
---

[目次ページはこちら](https://zenn.dev/a2not/articles/telemetry-index)

[Transparent Telemetry for Open-Source Projects](https://research.swtch.com/telemetry-intro)^["[Transparent Telemetry](https://research.swtch.com/telemetry)" © Russ Cox [Licensed under CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)]

ソフトウェアがどのように使われ、期待するパフォーマンスを発揮しているかを知るためのモダンな手法として、Russはtelemetryを上げています。その上で、それをオープンソース向けにした新たなデザインとして"Transparent Telemetry"を提案しています。

# [Why Telemetry?](https://research.swtch.com/telemetry-intro#why)

telemetry以外にソフトウェアのバグや使われ方の情報を知れる手段としてバグ報告とサーベイをあげ、それぞれでは不十分であることを解説し、telemetryの必要性を訴えています。

## バグ報告だけでは不十分

バグ報告では、ユーザーがバグと判定しその上で報告をされたものしか知ることができないが、ユーザーが気づけない事象についてtelemetryでは統計的に不具合を認識することができるとして、過去のGo開発からの具体例を上げています。

Go 1.14のリリースプロセスにおいて、Appleの署名ツールを使えるようmacOS用のGoディストリビューションのビルド方法を調整したが、それによってすべてのプリコンパイルされた`.a`ファイルが古いと判定される状態で提供されました。
その結果、`go`コマンドが初回実行時に標準ライブラリを再ビルドし、`cgo`を使う`net`パッケージを利用する際にXcodeが必要となってしまいました。
ユーザー目線では、XcodeがないmacOSの環境で`go`が`clang`を実行する際には、Xcodeをインストールするポップアップが表示されるが、ユーザーはそれが必要だと感じたか、`go`によってXcodeが必要とされているということすら認識できなかった可能性があり、結局このバグは3年以上もの間誰からも報告されずその存在を認知されませんでした。

telemetryがあれば、1.14移行のバージョンのGoを使っているMacの環境についてプリコンパイルされた標準ライブラリへのキャッシュミス率が100%であることが分かるため、すぐに気づくことができたのではないかと主張しています。

## サーベイだけでは不十分

サーベイではユーザーがGoをどんな目的で使いたいかなどを理解できたが、これはあくまで少ないサンプルであり、特に使われる頻度の少ない機能についての情報を集めるためには、精度を高めるためにさらに大きなサンプルを必要とする問題があります。

Goでの使われる頻度の少ない機能への変更例として、[Go1.13のNative Client (`GOOS=nacl`)のサポート終了](https://go.dev/doc/go1.13#ports)や、[Go1.15の32bit Intel CPUでのSSE2命令セットをサポートしない浮動小数点ハードウェア(`GO386=387`)のサポート終了](https://go.dev/doc/go1.15#386)が挙げられていますが、いずれも影響範囲の規模感について概ね予測通りの結果であったようです。

しかし失敗例として、Go1.18の`-buildmode=shared`の削除についてドラフトに組み込んだが、Go1.18 ベータ1のリリース時点で「まだ使ってるから消さないで」とのフィードバックがあり、[削除を諦めた](https://github.com/golang/go/issues/47788)という過去もあったようです。

メンテナンスコストを軽減するために検討されているものとして、モダンなアトミック命令のないARMv5 (`GOARM=5`)サポート終了などもあります。最近で言えばGo1.20でmacOS High Sierraのサポートを終了することも検討されたが、ユーザーから[保留してほしいとの意見](https://github.com/golang/go/issues/57125#issuecomment-1416277589)が上がったようです。

telemetryも完璧なものではないですが、使わない機能や問題のある機能についてメンテナンスを続けるよりは、大きなサンプルのユーザーへのサーベイをする必要なく、統計的に利用状況を確認できるtelemetryを導入する必要性はあるのかもしれません。

# [Why Telemetry For Open Source?](https://research.swtch.com/telemetry-intro#why-open-source)

telemetryと聞くと、プライベートな部分まで情報収集されてしまうというようなネガティブなイメージを直感で持たれる方も少なくないのではないでしょうか。

キーボードによる入力の一つ一つまでを収集されるというのは誇張かもしれませんが、あながち間違いでもないと感じるのも以下の現実に起きている例から納得できます。

- [Kindleがページ送りのすべてを収集してる](https://www.theverge.com/2020/1/31/21117217/amazon-kindle-tracking-page-turn-taps-e-reader-privacy-policy-security-whispersync)
- [VS Codeのtelemetryログ](https://www.roboleary.net/tools/2022/04/20/vscode-telemetry.html)
- [.NETのtelemetryイベント](https://learn.microsoft.com/en-us/dotnet/core/tools/telemetry)

そのようなイメージもあるのか、オープンソースのソフトウェアプロジェクトでは主に2つの理由からtelemetryを避ける傾向にあります。1つはユーザーに対する大きなプライバシーコストの懸念、もう一つは従来のtelemetryの性質上集めた情報に対するアクセスを制限する必要があり、オープンソースであるプロジェクトの方向性に反するものとなるためです。

telemetryを導入しない(何もしない)方が簡単ですが、それによって先に述べた、「使われていない機能に関するメンテナンス」や「ユーザー体験を損なう、バグや不具合などを含んだリリース」に対して時間を無駄に割いてしまうデメリットを被ります。

Russは「侵略的なまでのtelemetryによるトラッキング」と「telemetryを導入せず何もしない」は誤った二分法であり、オープンソースを傷つけていると主張しています。こういった情報収集やそれによるGo言語開発の優先順位付けを行えないことが、メンテナの燃え尽きにつながるのではないかということです。

Eric Raymondは「十分目玉に晒されていれば、すべてのバグは浅い(`“given enough eyeballs, all bugs are shallow,”`)」と言い、説明として十分なベータテスターと開発者仲間があれば、ほとんどの問題は認識され解決されるとしました。
しかし、現代のオープンソースソフトウェアは昔と比べて、それを開発したりどのように動くのかについて詳しくない人を含む多くの人々から使われるようになったにもかかわらず、認知までに時間を要した先述のmacOSのGoのキャッシュバグの例からも、目玉はスケールしないことがわかります。

オープンソースソフトウェアのための、プライバシーを侵害しない必要最低限のユーザーアクティビティの収集から開発を効率化させられる、新しいtelemetryのデザインを考える必要があるでしょう。

# [Transparent Telemetry](https://research.swtch.com/telemetry-intro#design)

このシリーズで提案するTransparent Telemetryは、オープンソースのためのtelemetryで、最小限のデータ収集(年間で数キロバイト程度)と、集めた情報のすべてを公開する方針からその名前がついています。(「透過的テレメトリ」)

ここでは、将来的にGoツールチェーンに導入を検討しているTransparent Telemetryの概要を紹介しています。

## telemetryによる情報の収集
GoツールチェーンのTelemetryにおいては、実行ごとにキャッシュヒット、利用した機能、レイテンシなどの情報を一週間ごとにディスクにファイルとして保存するようです。ユーザーのデータやユーザーを識別するような情報は含まず、一部で簡潔なスタックトレースなども保存するが、引数についての情報は一切保存しない方針です。

GoogleのGoチームがtelemetryの情報収集用のサーバーを管理し、毎週10%の確率でユーザー環境に収集設定(`collection configuration`)をダウンロードして、どの情報をサーバーが欲しているのかを判断します。収集設定はGo moduleノカタチで配布されるため、Go checksum databaseでvalidateされています。
収集設定のサンプル率に基づいて(大抵2%程度、平均して環境につき年に一回程度)、telemetry収集用のサーバーにログを送信します。

先述の通り、データにはIDなどユーザーを識別する情報を含みません。例えば、ユーザー名、マシンID、MACアドレス、IPアドレス及びそのプレフィックス、マシンの位置情報、ランダムに生成された擬似的なIDも含みません。
含まれる想定の情報としては、ツールチェーンのバージョンやビルドターゲットとされたOSやCPUアーキテクチャ、荒い粒度でのホストOSの情報(`"Windows 8"`など)、ツールチェーンが利用したローカルのCコンパイラなどの他のツールの情報(`"gcc 2.95"`)などがあります。

## 集めた情報の公開

集めた情報のアクセスとしては、毎日の収集情報の更新、telemetryのグラフなどの`go.dev`での公開、集まった情報をすべてダウンロード可能にする予定のようです。

データを集めるためにTCPコネクションを利用した場合、システムのパブリックIPアドレスがデータに紐付くことになりますが、それらの情報については設定されるプライバシーポリシーに基づき、アップロードされ公開される前に切り離されます。
というのも、DoS対策などを含むサーバーのメンテナンスのためにIPアドレスを含むログが必要になるため、IPアドレスは削除ではなく保存される必要があるのですが、公開されるデータとは別で保存されるようです(おそらく非公開で、サーバーの運用のためだけに使われる?)。

## 利用方法

Proposalでは次の点は議論の対象になっていましたが、記事では`GOTELEMETRY=off`が指定されない限りは、デフォルトでtelemetryが収集され、opt outする猶予期間としてツールチェーンのインストールから最低でも一週間は`GOTELEMETRY`の設定に関わらずデータは送信されないと記述されていました。

ちなみにDiscussionsでは、「[デフォルトでoff、そうでなければ事前にon/offを選択させるべき](https://github.com/golang/go/discussions/58409#discussioncomment-4905912)」という意見が多く支持を集めているようです。
この点についてRussは、議論を受けて追記した4つ目の記事で方針を表明しているようです。

# [Summary](https://research.swtch.com/telemetry-intro#summary)

従来のtelemetryとは異なる、Transparent Telemetryの持つ特性についてまとめています。

(追加情報なども一部ありますが、省略します。)

# [Next Steps](https://research.swtch.com/telemetry-intro#next_steps)

Transparent Telemetryの詳細なデザイン(設計)については次の2本目の記事、ユースケースについてはその次の3本目の記事で詳細を記述しています。

ここでは、VS Codeがtelemetryによって粒度の高い詳細な情報を集めているが、集めているデータをよく見ると、異なるイベントで発生したデータ間において新たな情報が少なく似たようなログの羅列となっている点を指摘し、Transparent Telemetryのように必要最小限に収めることで不要なプライバシーコストをユーザーに負担させる必要もなくなるのではという意見も残しています。

Russはローカルでのプロトタイプの実装から、GoツールチェーンにTransparent Telemetryを組み込むパフォーマンスコストが十分に小さいと確信していて、2023年を通して実装していきたいと表明していました。

